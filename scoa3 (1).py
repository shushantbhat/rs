# -*- coding: utf-8 -*-
"""Scoa3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wrFAZiEi_mN-9CdwWqo7hX_i_W5M8p7t
"""

!pip install Scikit-fuzzy

import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# ------------------------------
# Step 1: Define fuzzy variables
# ------------------------------
error = ctrl.Antecedent(np.arange(-10, 11, 1), 'error')
delta_error = ctrl.Antecedent(np.arange(-5, 6, 1), 'delta_error')
torque = ctrl.Consequent(np.arange(-10, 11, 1), 'torque')

# ------------------------------
# Step 2: Define membership functions
# ------------------------------
error['neg'] = fuzz.trimf(error.universe, [-10, -10, 0])
error['zero'] = fuzz.trimf(error.universe, [-10, 0, 10])
error['pos'] = fuzz.trimf(error.universe, [0, 10, 10])

delta_error['neg'] = fuzz.trimf(delta_error.universe, [-5, -5, 0])
delta_error['zero'] = fuzz.trimf(delta_error.universe, [-5, 0, 5])
delta_error['pos'] = fuzz.trimf(delta_error.universe, [0, 5, 5])

torque['neg'] = fuzz.trimf(torque.universe, [-10, -10, 0])
torque['zero'] = fuzz.trimf(torque.universe, [-10, 0, 10])
torque['pos'] = fuzz.trimf(torque.universe, [0, 10, 10])

# ------------------------------
# Step 3: Define fuzzy rules
# ------------------------------
rules = [
    ctrl.Rule(error['neg'] & delta_error['neg'], torque['neg']),
    ctrl.Rule(error['neg'] & delta_error['zero'], torque['neg']),
    ctrl.Rule(error['neg'] & delta_error['pos'], torque['zero']),
    ctrl.Rule(error['zero'] & delta_error['neg'], torque['neg']),
    ctrl.Rule(error['zero'] & delta_error['zero'], torque['zero']),
    ctrl.Rule(error['zero'] & delta_error['pos'], torque['pos']),
    ctrl.Rule(error['pos'] & delta_error['neg'], torque['zero']),
    ctrl.Rule(error['pos'] & delta_error['zero'], torque['pos']),
    ctrl.Rule(error['pos'] & delta_error['pos'], torque['pos'])
]

# ------------------------------
# Step 4: Create control system
# ------------------------------
torque_ctrl = ctrl.ControlSystem(rules)
torque_sim = ctrl.ControlSystemSimulation(torque_ctrl)

# ------------------------------
# Step 5: Simulate fuzzy control surface
# ------------------------------
target_angle = 30.0
arm_angle, arm_vel = 0.0, 0.0
angles = []
timesteps = 100
dt = 0.1 # Time step

for _ in range(timesteps):
    # Calculate crisp inputs
    e = target_angle - arm_angle
    de = -arm_vel # Change in error is proportional to negative velocity

    # Check for stability (if close enough, just stop)
    if abs(e) < 0.1 and abs(arm_vel) < 0.1:
        calculated_torque = 0
    else:
        # Fuzzification & Inference & Defuzzification
        torque_sim.input['error'] = e
        torque_sim.input['delta_error'] = de

        try:
            torque_sim.compute()
            # Defuzzification (Centroid method is default)
            calculated_torque = torque_sim.output['torque']
        except ValueError:
            # Handle cases where input is outside universe (shouldn't happen with proper scaling)
            calculated_torque = 0

    # Apply torque (Physics Simulation - Simple Euler Integration)
    # New velocity = Old velocity + (Torque * Gain)
    arm_vel += 0.2 * calculated_torque * dt
    # New angle = Old angle + (Velocity * dt)
    arm_angle += arm_vel * dt
    angles.append(arm_angle)

# --- 6. Plot Results ---
plt.figure(figsize=(10, 5))
plt.plot(angles, label='Arm Angle')
plt.axhline(target_angle, color='r', linestyle='--', label='Target Angle')
plt.title("Robotic Arm Angle Convergence (Mamdani Fuzzy Logic)")
plt.xlabel(f"Time Step ({dt*timesteps}s total)")
plt.ylabel("Angle (degrees)")
plt.legend()
plt.grid(True)
plt.show()

